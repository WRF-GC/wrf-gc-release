!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!               __          _______  ______       _____  _____                 !
!               \ \        / /  __ \|  ____|     / ____|/ ____|                !
!                \ \  /\  / /| |__) | |__ ______| |  __| |                     !
!                 \ \/  \/ / |  _  /|  __|______| | |_ | |                     !
!                  \  /\  /  | | \ \| |         | |__| | |____                 !
!                   \/  \/   |_|  \_\_|          \_____|\_____|                !
!                                                                              !
!------------------------------------------------------------------------------!
!         WRF-GC - two-way, nested coupled meteorology-chemistry model         !
!                         2022 Technology Preview R1                           !
!------------------------------------------------------------------------------!
!  Formerly known as WRF-GCHP, WRF-GIGC. GCHP-powered chemistry add-on for WRF !
!  WRF & GCHP are (c) their original authors.                                  !
!  WRF-GC coupling layer (c) Haipeng Lin, Xu Feng, Tzung-May Fu                !
!  Developed at Atmospheric Chemistry and Climate Group, Peking U./SUSTech     !
!    by Haipeng Lin <hplin@seas.harvard.edu>, Xu Feng <fengx7@pku.edu.cn>      !
!    April 2018                                                                !
!------------------------------------------------------------------------------!
!  Refer to the chem_driver.F chemistry driver for release history             !
!------------------------------------------------------------------------------!

!------------------------------------------------------------------------------
!                              The WRF-GC Project                             !
!------------------------------------------------------------------------------
!BOP
!
! !MODULE: wrfgc_convert_state_mod.F
!
! !DESCRIPTION: Module WRFGC\_Convert\_State\_Mod performs conversion of WRF
!  data structures to/from Grid-Independent GEOS-Chem (GIGC) State structures.
!  (hplin, 4/3/18)
!\\
!\\
! !INTERFACE:
module WRFGC_Convert_State_Mod

!
! !USES:
!
    ! WRF
    use module_domain
    use module_dm
    use module_model_constants
    use module_state_description
    use module_chem_utilities, only: calc_zenithb, getpar, get_cloud_optical_depth, calc_slp
    use module_convection_prep

    ! GEOS-Chem
    use GIGC_Chunk_Mod
    use PRECISION_MOD
    use Species_Mod,    only: MISSING_INT
    use ERROR_MOD,      only: IT_IS_NAN
    use Input_Opt_Mod,  only: OptInput
    use State_Chm_Mod,  only: ChmState, Ind_
    use State_Met_Mod,  only: MetState
    use State_Diag_Mod, only: DgnState
    use State_Grid_Mod, only: GrdState
#ifdef use_wrfgc_history_output
    ! WRF-GC
    use wrfgc_io_pnetcdf,only: writeDiag
#endif
    implicit none
    private

!
! !PUBLIC MEMBER FUNCTIONS:
!
    public :: WRFGC_IdxSetup
    public :: WRFGC_Get_WRF
    public :: WRFGC_Set_WRF
!
! !PRIVATE VARIABLES:
!
    integer :: gi_ch4

!
! !REMARKS:
!  This module provides Get\_WRF and Set\_WRF routines that will "Get" and "Set"
!  variables from/to WRF, respectively, to/from the State_Met, State_Chm vars.
!
! !REVISION HISTORY:
!  24 Apr 2018 - H.P. Lin  - First crack.
!  25 Apr 2018 - H.P. Lin  - Refactored to support WRF (i,j) bounds, dbg options,
!                            and WRF scalar, chem, moist arrays from _new_args.inc
!  07 May 2018 - H.P. Lin  - Allocate arrays when necessary only & support tiling instead of 1x1 col
!  17 May 2018 - H.P. Lin  - Added ProTeX headers and some variables from xfeng, 5/18.
!  12 Oct 2018 - H.P. Lin  - Add State_Diag for GEOS-Chem NetCDF Diagnostics
!  14 Nov 2018 - X. Feng   - Add Cumulus parameterization for ntiedtke
!  21 Nov 2018 - H.P. Lin  - Massive performance optimizations
!  12 Nov 2019 - H.P. Lin  - Now WRFGC\_Convert\_State\_Mod
!  18 Mar 2020 - H.P. Lin  - Update to GEOS-Chem 12.7.3
!  24 May 2020 - H.P. Lin  - Update to GEOS-Chem 12.8.1; fix met (xfeng); nested cpling.
!  12 Oct 2021 - H.P. Lin  - Fix WRFv4, update wetscav_frcing for RAINPROD, EVAPPROD
!  20 Apr 2022 - H.P. Lin  - Update to GEOS-Chem 13.4.0.alpha.28; add PM10 diagnostic
!  15 Jun 2022 - H.P. Lin  - Add diagikj8,9; gckpperror; support up to GEOS-Chem 14.0.0(rc)
!  11 Aug 2022 - H.P. Lin  - Use autogenerated code with new tools; support 14.0.0-rc.1
!------------------------------------------------------------------------------
!BOC
contains
!EOC
!------------------------------------------------------------------------------
!                              The WRF-GC Project                             !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: WRFGC_IdxSetup
!
! !DESCRIPTION: Subroutine WRFGC\_IdxSetup saves the State_Chm IND_ results into
!  a local scalar variable set so that we do not check the map every time from G-C,
!  when converting between internal states. (hplin, 11/21/18)
!\\
!\\
! !INTERFACE:
!
    subroutine WRFGC_IdxSetup(am_I_Root)
!
! !INPUT PARAMETERS:
!
        logical, intent(in) :: am_I_Root

        ! Code begins here!
        gi_ch4 = IND_('CH4')

        write(6,*) p_ch4, "ch4 = CH4", gi_ch4

    end subroutine WRFGC_IdxSetup
!EOC
!------------------------------------------------------------------------------
!                              The WRF-GC Project                             !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: WRFGC_Get_WRF
!
! !DESCRIPTION: Subroutine WRFGC\_Get\_WRF converts WRF data structures (grid, chem,
!  moist, scalar) according to WRF configuration (config_flags) to GIGC data structures
!  to call the GIGC_Chunk_Mod routines (State_Met, State_Chm). (hplin, 4/24/18)
!\\
!\\
! !INTERFACE:
!
    subroutine WRFGC_Get_WRF(am_I_Root, &
        config_flags, grid, &
        num_chem, chem, num_scalar, scalar, num_moist, moist, &
        dz8w, p8w, pi_phy, &
        f_qc, f_qi, f_qndrop, warm_rain, &
        its, ite, jts, jte, &
        ide, jde, &
        kts, kte, &
        ids, jds, kds, &
        curr_secs, &
        Input_Opt, State_Met, State_Chm, State_Grid, &
        WRFGC_Phys_Time)
        use PRESSURE_MOD,  only: ACCEPT_EXTERNAL_APBP

        implicit none

!
! !INPUT PARAMETERS:
!
        logical, intent(in) :: am_I_Root
        type(grid_config_rec_type), intent(in) :: config_flags

        type(domain), target :: grid
        integer, intent(in)  :: num_chem, num_scalar, num_moist ! # of WRF chem, moist variables. Check "dummy_new_args.inc" & "actual_new_args.inc" in WRF compile.
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33, num_chem), intent(in)   :: chem
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33, num_scalar), intent(in) :: scalar
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33, num_moist), intent(in)  :: moist
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33), intent(in)  :: dz8w, p8w, pi_phy
        integer, intent(in) :: its, ite, jts, jte, ide, jde, kts, kte, ids, jds, kds

        real(KIND=8) :: curr_secs
!
! !INPUT/OUTPUT PARAMETERS:
!
        type(OptInput), intent(inout) :: Input_Opt
        type(MetState), intent(inout) :: State_Met
        type(ChmState), intent(inout) :: State_Chm
        type(GrdState), intent(inout) :: State_Grid

        real(KIND=8), intent(inout)   :: WRFGC_Phys_Time  ! Cumulative time spent in physics/parameterization calculation time

!
! !REMARKS:
!  This code was originally created for a 1x1 (truly 1-D) column conversion, but later
!  changed to perform computation on the WRF parallelization tile (i,j,kts~e). These
!  are mapped to the GIGC_Chunk arrays II, JJ, k, dimension IM, JM, LM.
!
!  Please do take note that in WRF, memorder is XZY so arrays are (i, k, j), whereas in
!  GEOS-Chem the memorder is XYZ.
!
!  Also, the State_Chm conversion routines are auto-generated. Please use
!  https://github.com/jimmielin/wrf-gchp-dev-tools to generate them.
!  (hplin, 5/17/18)
!
! !REVISION HISTORY:
!  17 May 2018 - H.P. Lin   - Added ProTeX headers
!  29 May 2018 - X. Feng    - Fixed original extrapolated dummy %PEDGE
!  17 Aug 2018 - H.P. Lin   - Diagnose ApBp from WRF hybrid_grid and use those if available
!  14 Nov 2018 - X. Feng    - Add ntiedtke cumulus parameterization
!  14 Nov 2018 - H.P. Lin   - Add timers for physics parameterization & diagnostic output
!  01 Dec 2018 - H.P. Lin   - Add land type use code
!  12 Nov 2019 - H.P. Lin   - Now WRFGC\_Get\_WRF
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
        integer :: debug_level      ! WRF Debug Level
        integer :: GEOS_CHEM_RC     ! GEOS-Chem Return Code (0 = Success)

        integer :: IM, II           ! # of lons on this PET, calcd loop var
        integer :: JM, JJ           ! # of lats on this PET, calcd loop var
        integer :: LM               ! # of levs on this PET (no calcd because vertical always match)
        integer :: i, j, k          ! Loop variable over xts, xte (x = i, j, k)
        integer :: kk               ! Extra loop variable
        integer :: N
        integer :: ltop             ! Convective cloud top level

        real :: zen, pardb, pardif  ! For computing %SUNCOSmid, %PARDB, %PARDF
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33) :: cmfmc, pmflxrain, pmflxsnow    ! For computing %CMFMC, %PFLCU, %PFICU
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33) :: dqrcu  ! For computing %DQRCU
        integer, dimension(grid%sm31:grid%em31, grid%sm33:grid%em33) :: cloud_bot, cloud_top  ! For computing %DQRCU and %CONV_DEPTH
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33) :: dtrainu, dtraind, dtrain ! For computing %DTRAIN
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33) :: reevapcn ! For computing %REEVAPCN
        logical, dimension(grid%sm31:grid%em31, grid%sm33:grid%em33) :: cu_act_flag ! For cu_ntiedtke
        real, dimension(grid%sm31:grid%em31, grid%sm33:grid%em33) :: raincv_diag, pratec_diag ! For cu_ntiedtke
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33) :: rqccuten_diag, rqicuten_diag, rqvcuten_diag, rthcuten_diag, rucuten_diag, rvcuten_diag
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33) :: taucldc, taucldi, optd !For computing %TAUCLW, %TAUCLI, %OPTD
        real, dimension(grid%sm31:grid%em31, grid%sm33:grid%em33)                      :: slp                    !For computing %SLP
        logical, optional, intent(in) :: f_qc, f_qi, f_qndrop, warm_rain        

        ! For hybrid-grid in WRF
        real(fp), allocatable :: Ap(:)
        real(fp), allocatable :: Bp(:)

        ! For land use type in WRF
        character*256 :: mminlu_loc

        ! For temporary timers...
        real(KIND=8)          :: WRFGC_Time_Temp_Start, WRFGC_Time_Temp_End

        logical, save, dimension(1:8) :: FIRST = .true.      ! Is first run?

        ! Code begins below...
        call nl_get_debug_level(1, debug_level)
        call set_wrf_debug_level(debug_level)

        ! Get land use map type
        ! USGS or MODIFIED_IGBP_MODIS_NOAH, as validated by chemics_init.F
        call nl_get_mminlu(1, mminlu_loc) 

        IM = ite - its + 1
        JM = jte - jts + 1
        LM = kte - kts + 1

        ! write(6, *) "WRFGC_Convert_State_Mod ide =", ide, "jde =", jde
        ! write(6, *) "WRFGC_Convert_State_Mod its =", its, "ite =", ite, " IM =", IM
        ! write(6, *) "WRFGC_Convert_State_Mod jts =", jts, "jte =", jte, " JM =", JM
        ! write(6, *) "WRFGC_Convert_State_Mod kts =", kts, "kte =", kte, " LM =", LM

        ! Start WRF-GC Coupling Physics Timing (Timer-ID: gigc_get_0)
        ! Timer: WRFGC_Phys_Time
        WRFGC_Time_Temp_Start = MPI_Wtime()

        ! Save grid information
        State_Grid%ID          = grid%id       ! # of the WRF domain

        ! Compute grid sizes
        State_Grid%NX          = IM            ! # lons   on this PET
        State_Grid%NY          = JM            ! # lats   on this PET
        State_Grid%NZ          = LM            ! # levels on this PET

        ! GC does not need to know about this.
        State_Grid%GlobalNX    = IM            ! # lons   in global grid
        State_Grid%GlobalNY    = JM            ! # lats   in global grid
        State_Grid%NativeNZ    = LM            ! # levels in global grid
        State_Grid%XMinOffset  = 1             ! X offset from global grid
        State_Grid%XMaxOffset  = State_Grid%NX ! X offset from global grid
        State_Grid%YMinOffset  = 1             ! Y offset from global grid
        State_Grid%YMaxOffset  = State_Grid%NY ! Y offset from global grid

        ! Grid area must be passed in addition to State_Met!!!
        ! This is done in the loop below.

        ! Important debugging code for species list information
        if(debug_level .ge. 5 .and. FIRST(grid%id)) then
            ! Debug State_Chm
            write(6, *) "%%%%%% WRFGC_Convert_State_Mod Chemistry State Export %%%%%%"
            write(6, *) "Units: ", State_Chm%Spc_Units
            do N = 1, State_Chm%nSpecies
                WRITE(6, *) "N:", N, State_Chm%SpcData(N)%Info%Name, &
                            "Is_Adv:", State_Chm%SpcData(N)%Info%Is_Advected
            enddo
        endif

        ! Compute required variables from WRF cumulus parameterization
        ! Preventing rewriting the values of the output from physical cumulus
        ! parameterization
        raincv_diag   = grid%raincv
        pratec_diag   = grid%pratec
        rqccuten_diag = grid%rqccuten
        rqicuten_diag = grid%rqicuten
        rqvcuten_diag = grid%rqvcuten
        rthcuten_diag = grid%rthcuten
        rucuten_diag  = grid%rucuten
        rvcuten_diag  = grid%rvcuten
        
        if(config_flags%cu_physics .eq. 16) then
            call cu_ntiedtke(                                         &
                 grid%dt, grid%itimestep, grid%stepcu                 &
                ,raincv_diag, pratec_diag, grid%qfx, grid%hfx         &
                ,grid%u_phy, grid%v_phy, grid%w_2, grid%t_phy         &
                ,moist(grid%sm31,grid%sm32,grid%sm33,p_qv)            &
                ,moist(grid%sm31,grid%sm32,grid%sm33,p_qc)            &
                ,moist(grid%sm31,grid%sm32,grid%sm33,p_qi)            &
                ,pi_phy, grid%rho                                     &
                ,grid%rqvften, grid%rthften                           &
                ,dz8w, grid%p_hyd, grid%p_hyd_w, grid%xland           & 
                ,cu_act_flag, grid%dx                                 &
                ,ids, ide, jds, jde, kds, kte+1                       &
                ,grid%sm31, grid%em31, grid%sm33, grid%em33           &
                ,grid%sm32, grid%em32                                 &
                ,its, ite, jts, jte, kts, kte                         &
                ,rthcuten_diag, rqvcuten_diag, rqccuten_diag          &
                ,rqicuten_diag, rucuten_diag, rvcuten_diag            &
                ,pmflxrain, pmflxsnow, cmfmc, dqrcu, cloud_bot        &
                ,cloud_top, dtrainu, dtraind, dtrain, reevapcn        )
        endif
        
        if(config_flags%ra_lw_physics .eq. 4) then
           call get_cloud_optical_depth(grid%t_phy, grid%p_hyd_w         &
               ,moist(grid%sm31,grid%sm32,grid%sm33,p_qc)                &
               ,moist(grid%sm31,grid%sm32,grid%sm33,p_qi)                &
               ,scalar(grid%sm31,grid%sm32,grid%sm33,p_qndrop)           &
               ,taucldc, taucldi, optd                                   &
               ,f_qc, f_qi, f_qndrop, warm_rain                          &
               ,grid%sm31, grid%em31, grid%sm33, grid%em33               &
               ,grid%sm32, grid%em32                                     &
               ,its, ite, jts, jte, kts, kte                             )
        write(6,*) "max optd", maxval(optd)
        write(6,*) "max taucldi", maxval(taucldi)
        write(6,*) "max taucldw", maxval(taucldc)
        endif
        
        call calc_slp(grid%t_2, grid%p, grid%pb,                        &
                      moist(grid%sm31,grid%sm32,grid%sm33,p_qv),        &
                      grid%ph_2, grid%phb, slp,                         &
                      ids, ide, jds, jde, kds, kte+1,                   &
                      grid%sm31, grid%em31, grid%sm33, grid%em33,       &
                      grid%sm32, grid%em32,                             &
                      its, ite, jts, jte, kts, kte)


        ! See if are using WRF hybrid-grid and diagnose Ap, Bp (hplin, 8/17/18)
        ! FIXME: This calls a lower-level G-C function available in -DMODEL_WRF
        ! Note that Ap is in [hPa]s and you should see a reasonable set of values in pressure_mod
        if(config_flags%hybrid_opt .eq. 2) then
            allocate(Ap(LM+1))
            allocate(Bp(LM+1))

            do k = kts, kte
                Ap(k) = (grid%c4f(k) + (1 - grid%c3f(k)) * grid%p_top) * .01_fp
                Bp(k) = grid%c3f(k)
            enddo

            Ap(LM+1) = grid%p_top / p1000mb * .01_fp
            Bp(LM+1) = 0

            ! Debug the vertical grid (copied from pressure_mod.F, G-C)
            ! WRITE( 6, '(a)'   ) REPEAT( '=', 79 )
            ! WRITE( 6, '(a,/)' ) 'V E R T I C A L   G R I D   S E T U P'
            ! WRITE( 6, '(a,/)' ) 'D I A G N O S E D   F R O M   W R F   M O D E L'
            ! WRITE( 6, '( ''Ap '', /, 6(f11.6,1x) )' ) Ap(:)
            ! WRITE( 6, '(a)'   )
            ! WRITE( 6, '( ''Bp '', /, 6(f11.6,1x) )' ) Bp(:)
            ! WRITE( 6, '(a)'   ) REPEAT( '=', 79 )

            call ACCEPT_EXTERNAL_APBP(State_Grid, Ap, Bp, GEOS_CHEM_RC)

            deallocate(Ap)
            deallocate(Bp)
        else
            write(6, *) "====================================================="
            write(6, *) "|               W A R N I N G (WRF-GC)              |"
            write(6, *) "====================================================="
            write(6, *) "  GEOS-CHEM USES A VERTICAL HYBRID-SIGMA GRID.       "
            write(6, *) "  WRF MUST BE CONFIGURED TO USE THIS GRID using the  "
            write(6, *) "  namelist option &dynamics: hybrid_opt = 2, and     "
            write(6, *) "  RECOMPILING with ./configure -hyb.                 "
            write(6, *) "                                                     "
            write(6, *) "  WE WERE *NOT* ABLE TO DETECT THIS IN YOUR WRF-GC   "
            write(6, *) "  CONFIGURATION, WHICH MEANS THE VERTICAL LEVELS MAY "
            write(6, *) "  BE INACCURATE AND OUTRIGHT WRONG. PLEASE CHECK.    "
            write(6, *) "====================================================="
        endif

        ! End WRF-GC Coupling Physics Timing (Timer-ID: gigc_get_0)
        ! Timer: WRFGC_Phys_Time
        WRFGC_Time_Temp_End = MPI_Wtime()
        WRFGC_Phys_Time = WRFGC_Phys_Time + (WRFGC_Time_Temp_End - WRFGC_Time_Temp_Start)
        ! End Timer gigc_get_0

        call wrf_debug(100, "WRFGC_Convert_State_Mod before State_Met% Conversion")

        !--------------------------------------------------------------
        ! Debugging
        !--------------------------------------------------------------
        ! write(6,*) "** begin debug **"
        ! write(6,*) "WRFGC_Convert_State_Mod, hplin debug grid%sm100200", size(grid%sm100200, 1), size(grid%sm100200, 2)
        ! write(6,*) grid%sm100200
        ! write(6,*) "WRFGC_Convert_State_Mod, hplin debug grid%sm000010", size(grid%sm000010, 1), size(grid%sm000010, 2)
        ! write(6,*) grid%sm000010
        ! write(6,*) "WRFGC_Convert_State_Mod, hplin debug grid%pslv_gc", size(grid%pslv_gc, 1), size(grid%pslv_gc, 2)
        ! write(6,*) grid%pslv_gc
        ! write(6,*) "WRFGC_Convert_State_Mod, hplin debug grid%p00"
        ! write(6,*) grid%p00
        ! write(6,*) "** end debug **"

        !--------------------------------------------------------------
        ! 2-D Variables (Surface Fields)
        !--------------------------------------------------------------
        ! Loop over WRF (IIPAR, JJPAR would be OK too but we are leading with WRF vars on this one)
        do j = jts, jte
        do i = its, ite
            II = i - its + 1
            JJ = j - jts + 1

            ! Prepare quantities zen for SUNCOS, PARDR, PARDF
            call calc_zenithb(grid%xlat(i, j), grid%xlong(i, j)*(-1.), grid%julday, grid%dt, grid%gmt, curr_secs, zen)

            ! ALBD              Visible surface albedo [1]
            State_Met%ALBD(II, JJ) = grid%albedo(i, j)

            ! AREA_M2           Grid box surface area [m^2]
            State_Met%AREA_M2(II, JJ) = grid%dx * grid%dy / grid%msftx(i, j) / grid%msfty(i, j)
            State_Grid%AREA_M2(II, JJ) = State_Met%AREA_M2(II, JJ)

            ! CLDFRC            Column cloud fraction [1]
            State_Met%CLDFRC(II, JJ) = grid%CLDT(i, j)

            ! CLDTOPS           Max cloud top height [levels]
            ! Used for G-C bpch diagnostics, not used for GIGC

            ! CONV_DEPTH        Convective cloud depth [m]
            if (config_flags%cu_physics .eq. 16) then
                ltop     = cloud_top(i, j)
                State_Met%CONV_DEPTH(II, JJ) = sum( State_Met%BXHEIGHT(II, JJ, 1:ltop) )
                if ( State_Met%CONV_DEPTH(II, JJ) .gt. 0. ) then
                    State_Met%CONV_DEPTH(II, JJ) = State_Met%CONV_DEPTH(II, JJ) - 1e+0_fp
                endif
            endif
            
            ! EFLUX             Latent heat flux [W/m^2]
            State_Met%EFLUX(II, JJ) = grid%LH(i, j)

            ! FLASH_DENS        Lightning flash density [#/km^2/s] | IC+CG flash rate [#/s]
            if (config_flags%lightning_option .eq. 1 .or. config_flags%lightning_option .eq. 2 ) then
                State_Met%FLASH_DENS(II, JJ) = ( grid%cg_flashrate(i, j) + grid%ic_flashrate(i, j) ) / State_Met%AREA_M2(II, JJ) * 1e+6_fp
            endif

            ! FRCLND            Olson land fraction [1]
            State_Met%FRCLND(II, JJ) = State_Met%FRLAND(II, JJ)

            ! FRLAND            Fraction of land [1]
            ! FROCEAN           Fraction of ocean [1]
            ! FRLAKE            Fraction of lake [1]
            ! FRSNO             Surface snow fraction [1]
            ! FRLANDIC          Fraction of land ice [1]
            if(grid%lu_mask(i, j) .eq. 0 .and. grid%lakemask(i, j) .eq. 0 .and. grid%snowh(i, j) .eq. 0) then
                 State_Met%FRLAND(II, JJ) = 1.0_fp
                 State_Met%FROCEAN(II, JJ) = 0.0_fp
                 State_Met%FRSNO(II, JJ) = 0.0_fp
                 State_Met%FRLAKE(II, JJ) = 0.0_fp
                 State_Met%FRLANDIC(II, JJ) = 0.0_fp
            else if(grid%lu_mask(i, j) .eq. 1) then
                 State_Met%FRLAND(II, JJ) = 0.0_fp
                 State_Met%FROCEAN(II, JJ) = 1.0_fp
                 State_Met%FRSNO(II, JJ) = 0.0_fp
                 State_Met%FRLAKE(II, JJ) = 0.0_fp
                 State_Met%FRLANDIC(II, JJ) = 0.0_fp
            else if(grid%lakemask(i, j) .eq. 1) then
                 State_Met%FRLAND(II, JJ) = 0.0_fp
                 State_Met%FROCEAN(II, JJ) = 0.0_fp
                 State_Met%FRSNO(II, JJ) = 0.0_fp
                 State_Met%FRLAKE(II, JJ) = 1.0_fp
                 State_Met%FRLANDIC(II, JJ) = 0.0_fp
            else if(grid%snowh(i, j) .ge. 0) then
                 State_Met%FRLAND(II, JJ) = 0.0_fp
                 State_Met%FROCEAN(II, JJ) = 0.0_fp
                 State_Met%FRSNO(II, JJ) = 1.0_fp
                 State_Met%FRLAKE(II, JJ) = 0.0_fp
                 State_Met%FRLANDIC(II, JJ) = 1.0_fp
            endif

            ! FRSEAICE          Surface sea ice fraction [1] | Sea ice fraction [1]
            State_Met%FRSEAICE(II, JJ) = grid%xice(i, j)

            ! LandTypeFrac      Olson landmap fraction per type (I,J,TYPE) [1]
            !
            ! XLAI              MODIS LAI per land type for this month, dims I,J,N
            ! Note that the third dimension is actually land type# - 1, as dry dep indexes
            ! start with 0.
            !
            ! IMPORTANT: State_Met%XLAI is average LAI for this surface type
            !  DIVIDED BY THE FRACTIONAL COVERAGE OF THIS SURFACE TYPE. Which means that
            !  it is calculated as
            !    S = 1...%IREG(I,J) (land use type minus 1 for drydep)
            !     State_Met%XLAI(I,J,S) = State_Met%XLAI_NATIVE(I,J,S+1) / landFrac
            !  Where landFrac is State_Met%LandTypeFrac(I,J,S+1)
            !  This means that it is scaled to be larger or equal to the original LAI
            !
            ! For now (hplin, xfeng with discussion 12/1/18) we decide to assign 1.0 fractions to land types
            ! based on grid%lu_index, so we don't have to scale XLAI from LAI for now.
            if(mminlu_loc .eq. 'USGS') then
                select case(int(grid%lu_index(i, j)))
                case (1, 31, 32, 33) ! Urban, residential
                    State_Met%LandTypeFrac(II, JJ, 2 ) = 1.0_fp
                    State_Met%XLAI        (II, JJ, 2 ) = grid%lai(i, j)
                case (2, 3, 4, 5, 6) ! Dryland Cropland, Cr/Grassland Mosaic, Cr/Woodland Mosaic
                    State_Met%LandTypeFrac(II, JJ, 39) = 1.0_fp ! Cool Irrigated Cropland
                    State_Met%XLAI        (II, JJ, 39) = grid%lai(i, j)
                case (7, 8, 9) ! Grassland, Shrubland, Mixed Sh/Gr
                    State_Met%LandTypeFrac(II, JJ, 43) = 1.0_fp ! Cold Grassland
                    State_Met%XLAI        (II, JJ, 43) = grid%lai(i, j)
                case (10) ! Savanna
                    State_Met%LandTypeFrac(II, JJ, 44) = 1.0_fp ! Woody Savanna
                    State_Met%XLAI        (II, JJ, 44) = grid%lai(i, j)
                case (11) ! Deciduous Broadleaf Forest
                    State_Met%LandTypeFrac(II, JJ, 6 ) = 1.0_fp
                    State_Met%XLAI        (II, JJ, 6 ) = grid%lai(i, j)
                case (12) ! Deciduous Needleleaf Forest
                    State_Met%LandTypeFrac(II, JJ, 5 ) = 1.0_fp
                    State_Met%XLAI        (II, JJ, 5 ) = grid%lai(i, j)
                case (13) ! Evergreen Broadleaf Forest
                    State_Met%LandTypeFrac(II, JJ, 7 ) = 1.0_fp
                    State_Met%XLAI        (II, JJ, 7 ) = grid%lai(i, j)
                case (14) ! Evergreen Needleleaf Forest
                    State_Met%LandTypeFrac(II, JJ, 4 ) = 1.0_fp ! Coniferous Forest
                    State_Met%XLAI        (II, JJ, 4 ) = grid%lai(i, j)
                case (15) ! Mixed forest
                    State_Met%LandTypeFrac(II, JJ, 25) = 1.0_fp
                    State_Met%XLAI        (II, JJ, 25) = grid%lai(i, j)
                case (16) ! Water bodies
                    State_Met%LandTypeFrac(II, JJ, 1 ) = 1.0_fp ! Inland/Sea Water
                    State_Met%XLAI        (II, JJ, 1 ) = grid%lai(i, j)
                case (18) ! Wooded Wetland
                    State_Met%LandTypeFrac(II, JJ, 14) = 1.0_fp ! Wooded Wet Swamp
                    State_Met%XLAI        (II, JJ, 14) = grid%lai(i, j)
                case (19) ! Barren or Sparsely Vegetated
                    State_Met%LandTypeFrac(II, JJ, 3 ) = 1.0_fp ! Low Sparse Grassland
                    State_Met%XLAI        (II, JJ, 3 ) = grid%lai(i, j)
                case (21) ! Wooded Tundra
                    State_Met%LandTypeFrac(II, JJ, 64) = 1.0_fp ! Wooden Tundra
                    State_Met%XLAI        (II, JJ, 64) = grid%lai(i, j)
                case (23) ! Bare Ground Tundra
                    State_Met%LandTypeFrac(II, JJ, 54) = 1.0_fp ! Barren Tundra
                    State_Met%XLAI        (II, JJ, 54) = grid%lai(i, j)
                case (24) ! Snow or Ice
                    State_Met%LandTypeFrac(II, JJ, 13) = 1.0_fp ! Glacier Ice
                    State_Met%XLAI        (II, JJ, 13) = grid%lai(i, j)
                case (25) ! Playa
                    State_Met%LandTypeFrac(II, JJ, 8 ) = 1.0_fp ! Bare Desert
                    State_Met%XLAI        (II, JJ, 8 ) = grid%lai(i, j)
                case default
                    ! default: Urban
                    State_Met%LandTypeFrac(II, JJ, 2 ) = 1.0_fp
                    State_Met%XLAI        (II, JJ, 2 ) = grid%lai(i, j)
                end select
            else if(mminlu_loc .eq. 'MODIFIED_IGBP_MODIS_NOAH') then

            endif

            ! LandTypeFrac      Olson landmap fraction per type (I,J,TYPE) [1]
            ! We translate each of the WRF land use maps to the Olson landmaps used by G-C below
            ! ... in the future, TBD
            ! if(mminlu_loc .eq. 'USGS') then
            !     ! 1 Inland/sea water
            !     !  = 16 Water Bodies
            !     State_Met%LandTypeFrac(II, JJ, 1) = grid%landusef(i, 16, j)

            !     ! 2 Urban
            !     !  = 1 Urban and Built-up Land
            !     State_Met%LandTypeFrac(II, JJ, 2) = grid%landusef(i, 1, j)

            !     ! 3 Low Sparse Grassland

            !     ! 4 Coniferous Forest

            !     ! 5 Deciduous Conifer Forest
            !     !  = 12 Deciduous Needleleaf Forest
            !     State_Met%LandTypeFrac(II, JJ, 5) = grid%landusef(i, 12, j)

            !     ! 6 Deciduous Broadleaf Forest
            !     !  = 11 Deciduous Broadleaf Forest
            !     State_Met%LandTypeFrac(II, JJ, 6) = grid%landusef(i, 11, j)

            !     ! 7 Evergreen Broadleaf Forests
            !     !  = 13 Evergreen Broadleaf Forests
            !     State_Met%LandTypeFrac(II, JJ, 7) = grid%landusef(i, 13, j)

            !     ! 8 Tall Grasses and Shrubs

            !     ! 9 Bare Desert

            !     ! 10 Upland Tundra

            !     ! 11 Irrigated Grassland

            !     ! 12 Semi Desert

            !     ! 13 Glacier Ice

            !     ! 14 Wooded Wet Swamp
            ! else if(mminlu_loc .eq. 'MODIFIED_IGBP_MODIS_NOAH') then
            ! endif
            
            ! GWETROOT          Root soil wetness [1]
            State_Met%GWETROOT(II, JJ) = grid%smois(i, 4, j)
            
            ! GWETTOP           Top soil moisture [1]
            State_Met%GWETTOP(II, JJ) = grid%smois(i, 1, j)
            
            ! HFLUX             Sensible heat flux [W/m^2]
            State_Met%HFLUX(II, JJ) = grid%hfx(i, j)

            ! LAI               Leaf area index [m^2/m^2] (online)
            State_Met%LAI(II, JJ) = grid%lai(i, j)

            ! MODISLAI          Daily LAI computed from monthly offline MODIS [m2/m2]
            State_Met%MODISLAI(II, JJ) = grid%lai(i, j)

            ! ITY
            ! LWI               Land/water indices [1]
            ! If LWI = 0 and ALBEDO < 0.695, is WATER box.
            !    LWI = 1 .. is LAND box.
            !    LWI = 2 .. is ICE box. (dao_mod.F)
            ! Currently, we are using LWI = 1 as a kludge. Fixme this from WPS data.
            
            if(grid%lu_mask(i, j) .eq. 0) then
                State_Met%LWI(II, JJ) = 1
            else if(grid%lu_mask(i, j) .eq. 1) then
                State_Met%LWI(II, JJ) = 0
            endif

            ! PARDR             Surface downwelling PAR direct flux [W/m^2] | from WRF module_bioemi_beis314.F:subroutine getpar
            ! PARDF             Surface downwelling PAR diffusive flux [W/m^2] | from WRF module_bioemi_beis314.F:subroutine getpar
            call getpar(grid%swdown(i, j), 0.01*(grid%p(i, kts, j)+grid%pb(i, kts, j)), zen, pardb, pardif)
            if (config_flags%ra_sw_physics .eq. 4) then
               State_Met%PARDR(II, JJ) = grid%swvisdir(i, j)
               State_Met%PARDF(II, JJ) = grid%swvisdif(i, j)
            else
               State_Met%PARDR(II, JJ) = 0.8_fp*pardb
               State_Met%PARDF(II, JJ) = 0.8_fp*pardif
            endif
            
            ! PBLH              PBL height [m]
            State_Met%PBLH(II, JJ) = grid%pblh(i, j)

            ! PBL_TOP_L         PBL layer k-index [1] | WRF: kpbl
            State_Met%PBL_TOP_L(II, JJ) = grid%kpbl(i, j)

            ! PHIS              Surface geopotential height [m^2/s^2] | geopotential height at max pressure [m]
            ! State_Met%PHIS(II, JJ) = 9.80665*(grid%ght_max_p(i, j))
            State_Met%PHIS(II, JJ) = grid%ph_2(i, kts, j) + grid%phb(i, kts, j)
            
            ! PRECANV           Anvil precipitation @ ground [kg/m^2/s]
            State_Met%PRECANV(II, JJ) = (grid%snowncv(i, j) + grid%graupelncv(i, j) + grid%hailncv(i, j))/grid%dt
            
            ! PRECCON           Convective precipitation @ ground [kg/m^2/s] | PRECIP rate from cumulus scheme [mm/s]*water density [kg/m^3]
            State_Met%PRECCON(II, JJ) = grid%pratec(i, j)
            
            ! PRECTOT           Total precipitation @ ground [kg/m^2/s] | rain+ice+snow+graupel precipitation rate at all levels [kg/m^2/s]
            State_Met%PRECTOT(II, JJ) = (grid%rainncv(i, j) + grid%snowncv(i, j) + grid%graupelncv(i, j) + grid%hailncv(i, j))/grid%dt + grid%pratec(i, j)
            
            ! PRECLSC           Non-anvil large-scale precipitation @ ground [kg/m^2/s]
            State_Met%PRECLSC(II, JJ) = grid%rainncv(i, j)/grid%dt

            ! PS1_WET           Wet sfc press at dt start [hPa] | surface pressure [Pa]
            ! PS2_WET           Wet sfc press at dt end [hPa]
            ! PSC2_WET          Wet interpolated sfc press [hPa]
            State_Met%PS1_WET(II, JJ) = .01*grid%psfc(i, j)
            State_Met%PS2_WET(II, JJ) = .01*(grid%psfc(i, j) + grid%dpsdt(i, j) * grid%dt)
            State_Met%PSC2_WET(II, JJ) = .01*grid%psfc(i, j)

            ! PS1_DRY           Dry sfc press at dt start [hPa] | Surface pressure - water vapor partial pressure
            ! PS2_DRY           Dry sfc press at dt end [hPa]
            ! PSC2_DRY          Dry interpolated sfc press [hPa]
            !
            ! from http://wiki.seas.harvard.edu/geos-chem/index.php/Moisture_Updates_in_v11-01 (Legacy implementation)
            ! GeosCore/dao_mod.F (New implementation)
            !
            ! FIXME (hplin): As this is online coupling, we do not have access to next dt info.
            ! Possibly port a diagnostics Pa/s tendency from WRFV3/
            ! module_diag_misc? Anyway, if grid%dpsdt (sfc prs tendency) is present, add it to PS2_DRY
            
            ! State_Met%PS1_DRY(II, JJ) = .01*grid%psfc(i, j) - max(moist(i, kts, j, p_qv) * (1._fp/(1._fp + moist(i, kts, j, p_qv))), 1.0e-30_fp) * 1.6072e-3_fp * grid%psfc(i, j)
            State_Met%PS1_DRY(II, JJ) = .01*grid%psfc(i, j) - 28.97e-3_fp*max(moist(i, kts, j, p_qv) * (1._fp / (1._fp + moist(i, kts, j, p_qv))), 1.0e-30_fp) /&
                                    (18.01e+0_fp + 10.96e-3_fp * max(moist(i, kts, j, p_qv) * (1._fp / (1._fp + moist(i, kts, j, p_qv))), 1.0e-30_fp)) * grid%psfc(i, j)
            State_Met%PS2_DRY(II, JJ) = State_Met%PS1_DRY(II, JJ) + .01 * grid%dpsdt(i, j) * grid%dt
            ! State_Met%PSC2_DRY(II, JJ) = .01*grid%psfc(i, j) - max(moist(i, kts, j, p_qv) * (1._fp / (1._fp + moist(i, kts, j, p_qv))), 1.0e-30_fp) * 1.6072e-3_fp * grid%psfc(i, j)
            State_Met%PSC2_DRY(II, JJ) = .01*grid%psfc(i, j) - 28.97e-3_fp*max(moist(i, kts, j, p_qv) * (1._fp / (1._fp + moist(i, kts, j, p_qv))), 1.0e-30_fp) /&
                                    (18.01e+0_fp + 10.96e-3_fp * max(moist(i, kts, j, p_qv) * (1._fp / (1._fp + moist(i, kts, j, p_qv))), 1.0e-30_fp)) * grid%psfc(i, j)

            ! QV2M              Specific humidity at 2m [kg/kg]   |
            ! TODO - 14.0.0
            State_Met%QV2M(II, JJ) = max(grid%q2(i, j) * (1._fp / (1._fp + grid%q2(i, j))) , 1.0e-30_fp)

            ! SEAICE00/.../90   Sea Ice Coverage
            ! FIXME (hplin): Set as 1.0 for 00 for now, used only for specialty simulations
            State_Met%SEAICE00(II, JJ) = 1.0_fp

            ! SLP               Sea level pressure [hPa]
            State_Met%SLP(II, JJ) = slp(i, j)

            ! SNODP             Snow depth [m] | Physical snow depth [m]
            State_Met%SNODP(II, JJ) = grid%snowh(i, j)

            ! SNOMAS            Snow mass [kg/m^2] | Snow water equivalent [kg/m^2]
            State_Met%SNOMAS(II, JJ) = grid%acsnow(i, j)
            
            ! SUNCOS            COS(Solar Zenith Angle) current time [1] | COS of solar zenith angle [1]
            State_Met%SUNCOS(II, JJ) = grid%coszen(i, j)
            
            ! SUNCOSmid         COS(SZA) at midpoint
            State_Met%SUNCOSmid(II, JJ) = cos(zen)

            ! SUNCOSsum is computed by HEMCO. hplin, 8/15/22

            ! SWGDN             Incident radiation @ ground [W/m^2] (RADSWG)
            State_Met%SWGDN(II, JJ) = grid%swdown(i, j)
            
            ! TO3               Total overhead O3 column [DU]
            if (.not. FIRST(grid%id)) then
                State_Met%TO3(II, JJ) = 0.0_fp
                do k = kts, kte
                   State_Met%TO3(II, JJ) =  State_Met%TO3(II, JJ) + chem(i, k, j, p_o3) * State_Met%AD(II, JJ, k) / (grid%dx * grid%dy / grid%msftx(i, j) / grid%msfty(i, j)) * 22.4e+0_fp / 28.97e+0_fp * 0.1_fp
                enddo
            endif

            ! TROPP             Tropopause pressure [hPa] | tropo_p [Pa]
            State_Met%TROPP(II, JJ) = grid%tropo_p(i, j) / 100.

            ! TS                Surface temperature [K]
            State_Met%TS(II, JJ) = grid%t2(i, j)

            ! TSKIN             Surface skin temperature [K]
            State_Met%TSKIN(II, JJ) = grid%tsk(i, j)
            
            ! U10M              E/W wind speed @ 10m height [m/s] | u10
            State_Met%U10M(II, JJ) = grid%u10(i, j)

            ! USTAR             Fraction velocity [m/s] | ust
            State_Met%USTAR(II, JJ) = grid%ust(i, j)
            
            ! UVALBEDO          UV surface albedo [1] | albedo
            State_Met%UVALBEDO(II, JJ) = grid%albedo(i, j)
            
            ! V10M              N/S wind speed @ 10m height [m/s] | v10
            State_Met%V10M(II, JJ) = grid%v10(i, j)

            ! Z0                Surface roughness length [m] | Time varying roughness length [m]
            State_Met%Z0(II, JJ) = grid%znt(i, j)
            
            ! CNV_FRC           Convective fraction, used by ESMF_ mode [1]

            !----------------------------------------------------------
            ! 3-D variables filled on bottom/top levels
            !----------------------------------------------------------
            ! Fill top levels
            State_Met%PFLCU(II, JJ, LM+1) = 0._fp
            State_Met%PFICU(II, JJ, LM+1) = 0._fp
            State_Met%PFLLSAN(II, JJ, LM+1) = 0._fp
            State_Met%PFILSAN(II, JJ, LM+1) = 0._fp
            
            ! PEDGE at bottom level [hPa]
            State_Met%PEDGE(II, JJ, kts) = 0.01_fp*grid%psfc(i, j)
!            State_Met%PEDGE(II, JJ, 1) = .01*((grid%ph_2(i, 1, j) + grid%phb(i, 1, j) - grid%ph_2(i, 3, j) - grid%phb(i, 3, j))/                                         &
!                                               (grid%ph_2(i, 1, j) + grid%phb(i, 1, j) - grid%ph_2(i, 2, j) - grid%phb(i, 2, j))*(grid%p(i, 1, j) + grid%pb(i, 1, j)) +  &
!                                               (grid%ph_2(i, 3, j) + grid%phb(i, 3, j) - grid%ph_2(i, 2, j) - grid%phb(i, 2, j))/                                        &
!                                               (grid%ph_2(i, 1, j) + grid%phb(i, 1, j) - grid%ph_2(i, 2, j) - grid%phb(i, 2, j))*(grid%p(i, 2, j) + grid%pb(i, 2, j)))
            
            ! PEDGE at top level [hPa]
            ! Need to cap at 0.3 hPa (the top level must be < 0.3 hPa) or linoz will
            ! crash.
            State_Met%PEDGE(II, JJ, LM+1) = 0.01_fp*grid%p_top
            if(State_Met%PEDGE(II, JJ, LM+1) .ge. 0.3_fp) then
                State_Met%PEDGE(II, JJ, LM+1) = 0.29_fp
            endif

!            State_Met%PEDGE(II, JJ, LM + 1) = .01*(exp((grid%ph_2(i, 1, j) + grid%phb(i, 1, j) - grid%ph_2(i, 3, j) - grid%phb(i, 3, j))/                                &
!                                                      (grid%ph_2(i, 1, j) + grid%phb(i, 1, j) - grid%ph_2(i, 2, j) - grid%phb(i, 2, j))*                                 &
!                                                   log(grid%p(i, kte, j) + grid%pb(i, kte, j)) +                                                                         &
!                                                      (grid%ph_2(i, 3, j) + grid%phb(i, 3, j) - grid%ph_2(i, 2, j) - grid%phb(i, 2, j))/                                 &
!                                                      (grid%ph_2(i, 1, j) + grid%phb(i, 1, j) - grid%ph_2(i, 2, j) - grid%phb(i, 2, j))*                                 &
!                                                   log(grid%p(i, kte-1, j) + grid%pb(i, kte-1, j))))
        enddo
        enddo

        call wrf_debug(100, "WRFGC_Convert_State_Mod after 2-D State_Met% Conversion")

        ! Loop over WRF tile but in GEOS-Chem order as we are writing to GEOS-Chem
        ! Remember, for 3-D looping over (I, J, K) loops should be written outermost to innermost
        ! to make the most efficient use of the column-first order in Fortran
        !
        ! Top levels and lowermost levels (edge conditions) are now filled in the 2-D loop that
        ! does not loop over k
        do k = kts, kte
        do j = jts, jte
        do i = its, ite
            II = i - its + 1
            JJ = j - jts + 1

            !--------------------------------------------------------------
            ! 3-D Variables
            !
            ! For 3-D Variables, there is one unified loop that performs
            ! the conversions over vertical levs.
            !--------------------------------------------------------------

            ! PEDGE             Wet air pressure at (vertial) level edges [hPa]
            if(k .ne. kts) then ! Start from kts + 1
                State_Met%PEDGE(II, JJ, k) = .01_fp*(grid%c3f(k)*(grid%psfc(i, j) - grid%p_top) + grid%c4f(k) + grid%p_top)
!                State_Met%PEDGE(II, JJ, k) = .01*(grid%fnm(k)*(grid%p(i, k, j) + grid%pb(i, k, j)) + grid%fnp(k)*(grid%p(i, k-1, j) + grid%pb(i, k-1, j)))
            endif

            ! CLDF              3-D cloud fraction [1]
            State_Met%CLDF(II, JJ, k) = grid%cldfra(i, k, j)

            ! CMFMC                               Upward moist convective mass flux [kg/m^2/s] (max:LM+1)
            if(config_flags%cu_physics .eq. 10) then
                State_Met%CMFMC(II, JJ, k) = grid%mfup_cup(i, k, j)
            else if(config_flags%cu_physics .eq. 7) then
                State_Met%CMFMC(II, JJ, k) = grid%cmfmcdzm(i, k, j)
            else if(config_flags%cu_physics .eq. 16) then
                State_Met%CMFMC(II, JJ, k) = cmfmc(i, k, j)
            endif

            ! T                 Temperature [K]
            ! These calculations are linked, do not change their order and place them first
            State_Met%T(II, JJ, k) = (grid%t_2(i, k, j) + t0)*((grid%p(i, k, j) + grid%pb(i, k, j))/p1000mb)**rcp

            ! DQRCU             Convective precipitation production rate [kg/kg(dry air)/s] | dq/dt due to deep convective rainout [kg/kg/s]
            if(config_flags%cu_physics .eq. 7) then
                State_Met%DQRCU(II, JJ, k) = grid%zmntprpd(i, k, j)
            else if(config_flags%cu_physics .eq. 16) then
                State_Met%DQRCU(II, JJ, k) = dqrcu(i, k, j)
            endif
            
            ! DQRLSAN           Large scale precipitation production rate [kg/kg(dry air)/s] | Rate of conversion of condensate to precipitation [kg/kg/s]
            if(config_flags%mp_physics .eq. 10 .or. config_flags%mp_physics .eq. 8 .or. &
               config_flags%mp_physics .eq. 6) then
                ! WRFv3
                ! State_Met%DQRLSAN(II, JJ, k) = grid%rainprod(i, k, j)

                ! WRFv4
                State_Met%DQRLSAN(II, JJ, k) = grid%wetscav_frcing(i, k, j, p_rainprod)
            else if(config_flags%mp_physics .eq. 11) then
                State_Met%DQRLSAN(II, JJ, k) = grid%prain3d(i, k, j)
            endif
            
            ! DTRAIN            Detrainment flux [kg/m^2/s]
            if(config_flags%cu_physics .eq. 7) then
                State_Met%DTRAIN(II, JJ, k) = grid%du3d(i, k, j)*grid%dp3d(i, k, j)*100._fp/9.8_fp
                if(State_Met%DTRAIN(II, JJ, k) > 0.5) then
                    State_Met%DTRAIN(II, JJ, k) = 0.5
                endif
            else if(config_flags%cu_physics .eq. 16) then
                State_Met%DTRAIN(II, JJ, k) = dtrain(i, k, j)
            endif

            ! OMEGA                  Updraft velocity [Pa/s]
            if(State_Met%AIRVOL(II, JJ, k) .ne. 0) then
                ! State_Met%OMEGA(II, JJ, k) = -9.8_fp*State_Met%AD(II, JJ, k)/State_Met%AIRVOL(II, JJ, k)*grid%w_2(i, k, j)
            endif

            ! QI                Ice mixing ratio [kg/kg dry air] || cloud ice mixing ratio [kg/kg]
            ! QL                Water mixing ratio [kg/kg dry air] || cloud water mixing ratio [kg/kg]
            ! QI, QL (WRF registry ikjftb on moist)
            State_Met%QI(II, JJ, k) = moist(i, k, j, p_qi)
            State_Met%QL(II, JJ, k) = moist(i, k, j, p_qc)

            ! REEVAPCN
            if(config_flags%cu_physics .eq. 7) then
                State_Met%REEVAPCN(II, JJ, k) = abs(grid%evapcdp3d(i, k, j))
            else if(config_flags%cu_physics .eq. 16) then
                State_Met%REEVAPCN(II, JJ, k) = abs(reevapcn(i, k, j)*State_Met%AD(II, JJ, k)/State_Met%AREA_M2(II, JJ))
            endif
            
            ! REEVAPLS
            if(config_flags%mp_physics .eq. 10 .or. config_flags%mp_physics .eq. 8 .or. &
               config_flags%mp_physics .eq. 6) then
                ! WRFv3
                ! State_Met%REEVAPLS(II, JJ, k) = abs(grid%evapprod(i, k, j))

                ! WRFv4
                State_Met%REEVAPLS(II, JJ, k) = grid%wetscav_frcing(i, k, j, p_evapprod)
            else if(config_flags%mp_physics .eq. 11) then
                State_Met%REEVAPLS(II, JJ, k) = abs(grid%nevapr3d(i, k, j))
            endif

            ! RH                Relative humidity [%]
            State_Met%RH(II, JJ, k) = max(.1, min(.95, moist(i, k, j, p_qv)/ &
                                   (3.80*exp(17.27*(State_Met%T(II, JJ, k) - 273.)/ &
                                             (State_Met%T(II, JJ, k) - 36.))/(.01*(grid%p(i, k, j) + grid%pb(i, k, j)))))) * 100

            ! SPHU              Specific humidity [g H2O/kg tot air]
            ! SPHU1             ... at ts start [g/kg]
            ! SPHU2             ... at ts end [g/kg]
            ! Compute specific humidities based on moisture data
            ! from module_cam_mam_gas_wetdep_driver:168
            State_Met%SPHU(II, JJ, k) = max(moist(i, k, j, p_qv) * (1._fp / (1._fp + moist(i, k, j, p_qv))), 1.0e-30_fp)
            State_Met%SPHU1(II, JJ, k) = State_Met%SPHU(II, JJ, k)
            if(config_flags%cu_physics .eq. 7) then
                State_Met%SPHU2(II, JJ, k) = State_Met%SPHU(II, JJ, k) + grid%zmdq(i, k, j)*1.0e3_fp*grid%dt
            else ! Unsupported physics option
                State_Met%SPHU2(II, JJ, k) = State_Met%SPHU(II, JJ, k)
            endif

            ! U                 E/W component of wind [m/s] (from WRF U - X cmp)
            ! V                 N/S component of wind [m/s] (from WRF V - X cmp)
            if(i .ne. ide) then
                State_Met%U(II, JJ, k) = 0.5*(grid%u_2(i, k, j) + grid%u_2(i + 1, k, j))
            else
                State_Met%U(II, JJ, k) = grid%u_2(i, k, j)
            endif

            if(j .ne. jde) then
                State_Met%V(II, JJ, k) = 0.5*(grid%v_2(i, k, j) + grid%v_2(i, k, j + 1))
            else
                State_Met%V(II, JJ, k) = grid%v_2(i, k, j)
            endif

            ! TAUCLI                 Optical depth of ice clouds [1] | Cloud optical thickness for ice [1]
            ! TAUCLW                 Optical depth of H20 clouds [1] | Cloud optical thickness for water [1]
            ! OPTD                   Total in-cloud optical depth (visible band) 
            if(config_flags%ra_lw_physics .eq. 3 .or. config_flags%ra_lw_physics .eq. 5) then
                State_Met%TAUCLI(II, JJ, k) = grid%taucldi(i, k, j)
                State_Met%TAUCLW(II, JJ, k) = grid%taucldc(i, k, j)
                State_Met%OPTD(II, JJ, k) = State_Met%TAUCLI(II, JJ, k) + State_Met%TAUCLW(II, JJ, k)
            else if(config_flags%ra_lw_physics .eq. 4) then
                State_Met%TAUCLI(II, JJ, k) = taucldi(i, k, j)
                State_Met%TAUCLW(II, JJ, k) = taucldc(i, k, j)
                State_Met%OPTD(II, JJ, k) = optd(i, k, j)
            endif

            ! PFICU/PFLCU                         Downward flux of ice/liquid precipitation (convective) [kg/m^2/s] 
            if(config_flags%cu_physics .eq. 7) then
                State_Met%PFLCU(II, JJ, k) = grid%zmflxprc(i, k, j)
                State_Met%PFICU(II, JJ, k) = grid%zmflxsnw(i, k, j)
            else if(config_flags%cu_physics .eq. 16) then
                State_Met%PFLCU(II, JJ, k) = pmflxrain(i, k, j)
                State_Met%PFICU(II, JJ, k) = pmflxsnow(i, k, j)
            endif

            ! PFILSAN/PFLLSAN                    Downward flux of ice/liquid precipitation (Large-scale & Anvil) [kg/m^2/s]
            State_Met%PFLLSAN(II, JJ, k) = grid%precr(i, k, j)
            State_Met%PFILSAN(II, JJ, k) = grid%preci(i, k, j) + grid%precs(i, k, j) + grid%precg(i, k, j)

            ! TMPU1                              Temperature at start of timestep [K]
            ! TMPU2                              Temperature at end of timestep [K]
            ! Not used for main G-C, only in Met Fields by FlexGrid, but for safety set to %T
            State_Met%TMPU1(II, JJ, k) = State_Met%T(II, JJ, k)
            State_Met%TMPU2(II, JJ, k) = State_Met%T(II, JJ, k)

            ! UPDVVEL                            Updraft vertical velocity [hPa/s]
            if(State_Met%AIRVOL(II, JJ, k) .ne. 0) then
                ! State_Met%UPDVVEL(II, JJ, k) = -9.8_fp*State_Met%AD(II, JJ, k)/State_Met%AIRVOL(II, JJ, k)*grid%w_2(i, k, j)
            endif

            ! This code ONLY runs after all levels for given grid box are filled (k = LM)
            if(k .eq. kte) then
                ! A kludge that stops GEOS-CHEM CGM ("ChemGrid_Mod") GET_TPAUSE_LEVEL from breaking,
                ! when the T-PAUSE could not be found.
                ! WRF has a weaker stratosphere routine, so some grid boxes might NOT have a T-PAUSE at
                ! all. In this case, force CGM to recognize LLPAR (top level, LM) as T-PAUSE.
                ! Is T_PAUSE cond: State_Met%TROPP(I, J) >= State_Met%PEDGE(I, J, L_CURRENT)
                if(minval(State_Met%PEDGE(II, JJ, 1:LM)) .ge. State_Met%TROPP(II, JJ)) then
                    State_Met%TROPP(II, JJ) = minval(State_Met%PEDGE(II, JJ, 1:LM))
                    write(6, *) "WRFGC_Convert_State_Mod fixed T-PAUSE for GEOS-CHEM-CGM, set T-PAUSE to LLPAR"
                endif

                ! Calculate CLDTOPS (highest location of CMFMC in the column) (GC > 12.4)
                ! This can potentially be optimized further by collapsing this into the CMFMC loop
                ! but I will keep this consistent with GCHP for now (hplin, 12/31/19)
                State_Met%CLDTOPS(II,JJ) = 1
                do kk = LM, 1, -1
                    if(State_Met%CMFMC(II, JJ, kk) > 0d0) then
                        State_Met%CLDTOPS(II, JJ) = kk + 1
                    endif
                enddo
            endif

            ! Update chemistry concentrations in GEOS-Chem from WRF IC values
            if((.not. FIRST(grid%id)) .or. (config_flags%chem_in_opt .eq. 1 .and. FIRST(grid%id))) then
                State_Chm%Species(gi_ch4)%Conc(II, JJ, k) = chem(i, k, j, p_ch4) * 1.0e-6_fp

                ! A lot of non-advected species were removed here
                ! as we do NOT want them to be advected by WRF, so their concentrations
                ! should NOT be updated from WRF values. (hplin, 8/23/18)
            endif
        enddo ! Loop over i
        enddo ! Loop over j
        enddo ! Loop over k

        call wrf_debug(100, "WRFGC_Convert_State_Mod after 3-D State_Met% Conversion")

        call wrf_debug(100, "WRFGC_Convert_State_Mod after State Conversion")

        FIRST(grid%id) = .false.

    end subroutine WRFGC_Get_WRF
!EOC
!------------------------------------------------------------------------------
!                              The WRF-GC Project                             !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: WRFGC_Set_WRF
!
! !DESCRIPTION: Subroutine GIGC\_Set\_WRF converts GIGC data structures to
!  WRF data structures (grid, chem, moist, scalar) so that they are saved into
!  wrfout outputs and advected by the WRF dynamics core. (hplin, 4/24/18)
!\\
!\\
! !INTERFACE:
!
    subroutine WRFGC_Set_WRF(am_I_Root, &
        config_flags, grid, &
        num_chem, chem, num_scalar, scalar, num_moist, moist, &
        its, ite, jts, jte, &
        ide, jde, &
        kts, kte, &
        Input_Opt, State_Grid, State_Met, State_Chm, State_Diag)

        ! GEOS-Chem data structures
        use aerosol_mod, only:   PM25, PM10 ! GC 13.4 now has PM10

        ! HEMCO data structures
        use HCO_Utilities_GC_Mod, only:  HCO_GC_GetDiagn

        implicit none

!
! !INPUT/OUTPUT PARAMETERS:
!
        logical, intent(in) :: am_I_Root
        type(grid_config_rec_type), intent(in) :: config_flags
        type(domain), target :: grid

        integer, intent(in) :: num_chem, num_scalar, num_moist ! # of WRF chem, moist variables. Check "dummy_new_args.inc" & "actual_new_args.inc" in WRF compile.
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33, num_chem), intent(inout)   :: chem
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33, num_scalar), intent(inout) :: scalar
        real, dimension(grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33, num_moist), intent(inout)  :: moist

        integer, intent(in) :: its, ite, jts, jte, ide, jde, kts, kte

        type(OptInput), intent(inout) :: Input_Opt
        type(GrdState), intent(inout) :: State_Grid
        type(MetState), intent(inout) :: State_Met
        type(ChmState), intent(inout) :: State_Chm
        type(DgnState), intent(inout) :: State_Diag
!
! !REMARKS:
!  Please do take note that in WRF, memorder is XZY so arrays are (i, k, j), whereas in
!  GEOS-Chem the memorder is XYZ.
!
!  Also, the State_Chm conversion routines are auto-generated. Please use
!  https://github.com/jimmielin/wrf-gchp-dev-tools to generate them.
!  (hplin, 5/17/18)
!
! !REVISION HISTORY:
!  17 May 2018 - H.P. Lin   - Added ProTeX headers
!  12 Oct 2018 - H.P. Lin   - Add State_Diag for G-C netCDF diagnostics into WRF-GC output (wrfout)
!  13 Nov 2018 - H.P. Lin   - Add a temporarily kludge for MPI striping; merge in aerosol pm25
!  12 Nov 2019 - H.P. Lin   - Now WRFGC\_Set\_WRF
!  15 Jun 2022 - H.P. Lin   - Add State\_Grid; demo for HEMCO structures
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
        integer :: debug_level      ! WRF Debug Level
        integer :: N
        integer :: GEOS_CHEM_RC

        integer :: IM, II           ! # of lons on this PET
        integer :: JM, JJ           ! # of lats on this PET
        integer :: LM               ! # of levs on this PET
        integer :: i, j, k          ! Loop variable over xts, xte (x = i, j, k)

        ! Temporaries for retrieving data from HEMCO. They are reallocated at every call of this method
        ! because domains may switch. (hplin, 6/15/22)
        real(f4), pointer         :: ParaNOxLoss_O3  (:,:) => NULL()
        real(f4), pointer         :: ParaNOxLoss_HNO3(:,:) => NULL()

        ! Code below
        call nl_get_debug_level(1, debug_level)
        call set_wrf_debug_level(debug_level)

        ! # of lon, lat, lev in this PET
        IM = ite - its + 1
        JM = jte - jts + 1
        LM = kte - kts + 1

        ! write(6, *) "WRFGC_Convert_State_Mod::Set grid%id", grid%id
        ! write(6, *) "WRFGC_Convert_State_Mod::Set ide =", ide, "jde =", jde
        ! write(6, *) "WRFGC_Convert_State_Mod::Set its =", its, "ite =", ite, " IM =", IM
        ! write(6, *) "WRFGC_Convert_State_Mod::Set jts =", jts, "jte =", jte, " JM =", JM
        ! write(6, *) "WRFGC_Convert_State_Mod::Set kts =", kts, "kte =", kte, " LM =", LM

        ! write(6, *) "Sanity check: State_Chm% species sizing"
        ! write(6, *) "IM =", size(State_Chm%Species, 1)
        ! write(6, *) "JM =", size(State_Chm%Species, 2)
        ! write(6, *) "LM =", size(State_Chm%Species, 3)
        ! write(6, *) "SPC =", size(State_Chm%Species, 4)

        ! write(6, *) "Sanity check: State_Met%PEDGE sizing"
        ! write(6, *) "IM =", size(State_Met%PEDGE, 1)
        ! write(6, *) "JM =", size(State_Met%PEDGE, 2)
        ! write(6, *) "LM+1 =", size(State_Met%PEDGE, 3)

        ! When doing State_Chm% conversions, you can use State_Chm_Mod::IND_
        ! to retrieve a species ID for N value, e.g. id_O3 = IND_('O3'), so
        ! State_Chm%Species(id_O3)%Conc(:, :, :) holds the O3 information.
        !
        ! NEVER EVER USE IND_ IN A LOOP DIRECTLY, IT IS EXTREMELY SLOW
#ifdef use_wrfgc_history_output
        !------------------WRF-GC diagnostics module------------------!
        call wrf_debug(100, "WRFGC_Convert_State_Mod IO pnetCDF: Start writing diagnostics")
        call writeDiag(debug_level, Input_Opt, State_Met, State_Chm, grid, State_Grid, State_Diag, its, ite, jts, jte, ide, jde, kte)
        call wrf_debug(100, "WRFGC_Convert_State_Mod IO pnetCDF: End writing diagnostics")
#endif

        call wrf_debug(1, "WRFGC_Convert_State_Mod updating chemistry concs/diags in WRF from GEOS-Chem values")
        ! For now, "WRF-GC" style diagnostics from State_Diag are ALWAYS done.
        ! If you use gc_do_gcdiagn, it only turns on/off the G-C/C GCHP style HISTORY.rc diagns,
        ! it does not affect this.
        ! Loop over WRF tile
        do j = jts, jte
        do k = kts, kte
        do i = its, ite
            ! write(6, *) "Debug WRFGC_Convert_State_Mod::Set loop i, its", i, its
            ! write(6, *) "Debug WRFGC_Convert_State_Mod::Set loop j, jts", j, jts

            II = i - its + 1
            JJ = j - jts + 1

            ! Loop over WRF levels (same as GEOS-Chem levels since there is no global indexing here)
            ! write(6, *) "Debug WRFGC_Convert_State_Mod::Set in k loop IIJJk", II, JJ, k
            chem(i, k, j, p_ch4) = State_Chm%Species(gi_ch4)%Conc(II, JJ, k) * 1.0e+6_fp

            ! ---------------- WRF-GC DUMMY DIAGNOSTICS --------------- !
            ! Edit here to output internal properties of GEOS-Chem into WRF-GC output.
            ! The following code simply updates WRF diagnostics data for testing...

            !grid%diagikj0(i, k, j) = State_Met%CMFMC(II, JJ, k)
            !grid%diagikj1(i, k, j) = State_Met%PEDGE(II, JJ, k)
            !grid%diagikj2(i, k, j) = State_Met%PFLCU(II, JJ, k)
            !grid%diagikj3(i, k, j) = State_Met%TAUCLW(II, JJ, k)
            !grid%diagikj4(i, k, j) = State_Met%TAUCLI(II, JJ, k)
            !grid%diagikj5(i, k, j) = State_Met%AD(II, JJ, k)
            !grid%diagikj6(i, k, j) = State_Met%AIRVOL(II, JJ, k)

            ! LossCH4byClinTrop Loss CH4 by reaction with Cl [kg/s]
            !grid%diagikj7(i, k, j) = State_Diag%LossCH4byClinTrop(II, JJ, k)

            ! LossCH4byClinTrop Loss CH4 by reaction with OH [kg/s]
            !grid%diagikj8(i, k, j) = State_Diag%LossCH4byOHinTrop(II, JJ, k)

            ! CH4 emissions [kg/s], column. Stored in diagikj9 only
            !grid%diagikj9(i, 1, j) = State_Diag%CH4Emission(II, JJ)

            ! CH4 only - column diagnostics
            ! Air mass [kg]
            !grid%diagij0(i, j) = State_Diag%AirMassColumnFull(II, JJ)
            ! CH4 mass [kg], full-atmosphere and trop-only column sums
            !grid%diagij1(i, j) = State_Diag%CH4massColumnFull(II, JJ)
            !grid%diagij2(i, j) = State_Diag%CH4massColumnTrop(II, JJ)
            ! OH loss by CH4 + OH loss in troposphere [molec/s] and
            ! OH loss by MCF + OH loss in troposphere [molec/s]
            !grid%diagij3(i, j) = State_Diag%LossOHbyCH4columnTrop(II, JJ)
            !grid%diagij4(i, j) = State_Diag%LossOHbyMCFcolumnTrop(II, JJ)
            ! Mass-weighted mean OH [kg air * (kg OH m-3)]
            !grid%diagij5(i, j) = State_Diag%OHwgtByAirMassColumnFull(II, JJ)
        enddo
        enddo
        enddo

        ! For some reason this debug print is necessary.
        write(6,*) "hplin debug at coupler: 0,1,2,3,9", &
                   State_Diag%AirMassColumnFull(1,1), &
                   State_Diag%CH4massColumnFull(1,1), &
                   State_Diag%CH4massColumnTrop(1,1), &
                   State_Diag%LossOHbyCH4columnTrop(1,1), &
                   State_Diag%CH4Emission(1,1)

        !-----------------------------------------------------------------
        !         *****  D E B U G G I N G   R O U T I N E S  *****
        !-----------------------------------------------------------------

        ! After conversion if debug level is appropriately high
        if(debug_level .ge. 100) then
            ! Debug chemistry state and species information on PET (1, 1, 1) lowest lev.
            WRITE(6, *) "%%%% REGISTERED STATE_CHM SPECIES DUMP %%%%"
            do N = 1, MIN(State_Chm%nSpecies, 15)
                WRITE(6, *) "N:", N, "Name:", State_Chm%SpcData(N)%Info%Name
                ! WRITE(6, *) "Full Name:", State_Chm%SpcData(N)%Info%FullName
                WRITE(6, *) "Value at PET (1,1,1):", State_Chm%Species(N)%Conc(1, 1, 1)
            enddo
        endif
    end subroutine WRFGC_Set_WRF
!EOC
end module WRFGC_Convert_State_Mod
